---
title: "Three Node Example"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{three_node_example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## What is this for?

This shows inference on a data set drawn from a fully connected three node DAG.
As the number of possible three node DAGs is 25, this allows for a direct 
comparison between the expected and actual frequency of samples for each DAG.

```{r setup}
library(dagmc)
library(magrittr)
```

Create conditional probability tables. Plot the CPDAG.

```{r, error = TRUE}
# Three Node confounder problem
levels <- c('yes', 'no')
all_levels <- list(A = levels, B = levels, C = levels)

# Two-edge model
bn_arr <- list()
bn_arr[[1]] <- gRbase::parray(c('A', 'B'), levels = all_levels,
                              values = c(0.67, 0.33, 0.33, 0.67))
bn_arr[[2]] <- gRbase::parray('B', levels = all_levels,
                              values = c(0.5, 0.5))
bn_arr[[3]] <- gRbase::parray(c('C', 'B'), levels = all_levels,
                              values = c(0.33, 0.67, 0.9, 0.1))

nodes <- names(all_levels)
cpt <- gRain::compileCPT(bn_arr)
gr_dag <- gRain::grain(cpt)
true_dag <- as(gr_dag$dag, 'matrix')
plot(gr_dag)
```

Draw samples from the true DAG. There appears to be a bug somewhere here such that
set.seed does not work when running simulate using gRain. So you will get
irreproducible results for this script.

```{r, error = TRUE}
data <- stats::simulate(gr_dag, nsim = 100, seed = 1)
knitr::kable(head(data))
```

Calculate correlation matrix of the data.
```{r, error = TRUE}
knitr::kable(cor(1*(data == 'yes')))
```

## Calculate analytical probabilities for each graph

Get all possible graphs. 

```{r, error = TRUE}
GetAllDAGs <- function(nodes) {

  n <- length(nodes)
  n_tri <- n*(n - 1)/2
  tri_comb <- rep(list(c(0L, 1L)), n_tri)
  tri_val <- expand.grid(tri_comb)
  
  node_perm <- gtools::permutations(length(nodes), length(nodes), nodes)
  all_dags <- list()
  n <- 1
  for (i in 1:nrow(node_perm)) {
    for (j in 1:nrow(tri_val)) {
      mat <- matrix(
        0L,
        nrow = length(nodes), 
        ncol = length(nodes),
        dimnames = list(node_perm[i, ], node_perm[i, ])
        )
      mat[upper.tri(mat)] <- as.integer(tri_val[j, ])
      mat <- mat[nodes, nodes]
      
      all_dags[[n]] <- mat
      n <- n + 1
    }
  }
  all_dags <- unique(all_dags)
  
  return(all_dags)
}

all_dags <- GetAllDAGs(nodes)
```

Score all possible DAGs against the simulated data.

```{r, error = TRUE}
scorer <- CreateScorer(data = data, type = 'bde', cache = TRUE)

score_all_dags <- all_dags |>
  lapply(ScoreDAG, scorer = scorer) |>
  unlist()
hash_all_dags <- all_dags |>
  lapply(rlang::hash) |> 
  unlist()
```

Convert the scores into expected probabilities.

```{r, error = TRUE}
log_z <- LogSumExp(score_all_dags)
log_p <- score_all_dags - log_z
p_true <- exp(log_p)

p_summary <- data.frame(
  hash_dag = hash_all_dags, 
  p_true = p_true
)
```

## Sample from the posterior using MCMC

This gets n_results samples for each core. 

```{r, error = TRUE}
set.seed(1)
n_results <- as.integer(1e4)
n_chains <- 2

init_partitions <- list()
for (i in 1:n_chains) {
  init_dag <- UniformlySampleDAG(names(data))
  init_partitions[[i]] <- GetPartitionedNodesFromAdjacencyMatrix(init_dag)
}

# Only use the move-node proposal. There are some minor issues with following 
# detailed balance by using the others.
proposal <- DefaultProposal(p = c(0.0, 1.0, 0.0, 0.0, 0.0)) 
system.time(
  chains <- SampleChains(n_results, init_partitions,
                         transition = PartitionMCMC(proposal = proposal),
                         scorer = scorer,
                         n_parallel_chains = n_chains)
)
```

## Check the chains for convergence 

Looking at the trace of the partition log score.

```{r, error = TRUE, fig.dim = c(6.0, 4.0)}
PlotScoreTrace(chains, ylab = 'log(partition score)', type = 'l')
```

Converting the partitions into DAGs.

```{r, error = TRUE}
n_burnin <- 500
eq_chains <- PostProcessChains(chains, n_burnin)
eq_chains <- SampleChainDAGs(eq_chains, scorer)
```

Plot trace of DAG scores for equilibrium states.

```{r, error = TRUE, fig.dim = c(6.0, 4.0)}
PlotScoreTrace(eq_chains, attribute = 'log_dag_score', ylab = 'log(DAG score)', type = 'l')
```

## Convergence of the score trace

On inspection the score trace for both partitions and DAGs appears to have 
converged across chains. TODO: I should show a rolling average for each pairwise edge.

## Analysing acceptance rates

Acceptance per proposal after burnin.

```{r, error = TRUE}
prop_accept <- CalculateAcceptanceRates(eq_chains, group_by = 'proposal_used')
knitr::kable(prop_accept)
```

Overall acceptance proposal.

```{r, error = TRUE}
total_accept <- CalculateAcceptanceRates(eq_chains)
knitr::kable(total_accept)
```


## Estimating probabilities for each DAG


```{r, error = TRUE, fig.dim = c(6.0, 12.0)}
dags <- eq_chains |>
  lapply(function(x) x$dag) |> 
  unlist(recursive = FALSE)

n_chain_all <- dags |>
  lapply(rlang::hash) |>
  unlist() |>
  table()
p_chain_all <- n_chain_all/sum(n_chain_all)

i_order <- order(p_true, decreasing = TRUE)
graphics::par(mfrow = c(4, 2), mar = c(1, 1, 1, 1))
for (i in i_order) {
  hash_focus_dag <- hash_all_dags[i]
  focus_dag <- all_dags[[i]]
  
  bn_focus <- bnlearn::empty.graph(nodes)
  bnlearn::amat(bn_focus) <- focus_dag
  plot(bn_focus)
  
  t <- paste('p_est: ', round(p_chain_all[hash_focus_dag], 4), 
             ', p_true: ', round(p_true[i], 4), sep = '')
  graphics::text(300, 0, t)
}
```
